
    //cout << "Read event:"<<ev.eventnum()<<" Number of stubs="
    //	 <<ev.nstubs()<<endl;
    
    cleanTimer.start();
    for (unsigned int k=0;k<NSector;k++) {
      sectors[k]->clean();
    }

    /*    
    for (std::map<string,FPGADTC>::iterator it=dtcs.begin();it!=dtcs.end();it++){
    	it->second.clean();
    }
    */
  
    cleanTimer.stop();

    bool hitlayer[6];
    int stublayer[6];
    int stublayer1[6][NSector];
    for (unsigned int ll=0;ll<6;ll++){
      hitlayer[ll]=false;
      stublayer[ll]=0;
      for (unsigned int jj=0;jj<NSector;jj++){
        stublayer1[ll][jj]=0;
      }
    }
	
    int stubcount[6][24*NSector];	
    for (unsigned int ll=0;ll<24*NSector;ll++){
      stubcount[0][ll]=0;
      stubcount[1][ll]=0;
      stubcount[2][ll]=0;
      stubcount[3][ll]=0;
      stubcount[4][ll]=0;
      stubcount[5][ll]=0;
    }    

    addStubTimer.start();
    for (int j=0;j<ev.nstubs();j++){

      L1TStub stub=ev.stub(j);
      //if (stub.layer()>999) {
      //	 cout << "Found stub in disk : "<<stub.module()<<" r= "<<stub.r()
	// <<" z= "<<stub.z()<<endl;
      //}

     //cout << "Stub: layer="<<stub.layer()+1
	//      <<" pt="<<stub.pt()
	//       <<" phi="<<stub.phi()
	//      <<" r="<<stub.r()
	//      <<" z="<<stub.z()
	//       <<" ladder="<<stub.ladder()
	//       <<" module="<<stub.module()
	//       <<endl;


      if (stub.layer()<7) {

        //cout << "Stub in layer : "<<stub.layer()+1<<endl;

	hitlayer[stub.layer()]=true;

	stub.lorentzcor(-40.0/10000.0);

        double phi=stub.phi();
        if (phi<0.0) phi+=two_pi;
        unsigned int iphi=24*NSector*phi/two_pi;
        assert(iphi<24*NSector);
	double max=115.0;
	if (stub.layer()==0) max=70.0;
        if (fabs(stub.z())<max) stubcount[stub.layer()][iphi]++;
	unsigned int isector=iphi/24;
	assert(isector<NSector);
	stublayer1[stub.layer()][isector]++;
        stublayer[stub.layer()]++;

      }

      double phi=stub.phi();
      if (phi<0.0) phi+=two_pi;
      unsigned int isector=NSector*phi/two_pi;
      assert(isector<NSector);

      

      for (unsigned int k=0;k<NSector;k++) {
        int diff=k-isector;
	int nSector=NSector;
        if (diff>nSector/2) diff-=NSector;
        if (diff<-nSector/2) diff+=NSector;
	if (abs(diff)>1) continue;
        sectors[k]->addStub(stub);	  
      }

      
      //cout << "stub layer : "<<stub.layer()<<endl;
      /*
      if (writeDTCLinks) {

	int layer=stub.layer()+1;
	int ladder=stub.ladder(); 
	int module=stub.module();
	
	//HACK for mistake in ASCII files
	if (layer==3&&module==40) module=39;
	if (layer==1&&module>31) module=31;
	
	double dphi=two_pi/NSector;
	double phitmp=stub.phi();
	while (fabs(phitmp)>0.75*dphi) {
	  if (phitmp>0.0) {
	    phitmp-=dphi;
	  }
	  else {
	    phitmp+=dphi;
	  }
	}
	bool overlapregion=(fabs(phitmp)<dphi/6.0);
	bool overlaplayer=(layer%2==0);
	
	//cout << "Will add stub layer="<<layer<<" ladder="<<ladder
	//     <<" module="<<module<<" "<<stub.phi()<<endl;
	
	std::map<int, std::map<int, std::map<int, string> > >::const_iterator it1=modules.find(layer);
	assert(it1!=modules.end());
	std::map<int, std::map<int, string> >::const_iterator it2=it1->second.find(ladder);
	assert(it2!=it1->second.end());
	std::map<int, string>::const_iterator it3=it2->second.find(module);
	if (it3==it2->second.end()) {
	  cout << "Could not add stub "<<layer<<" "<<ladder<<" "
	       <<module<<" "<<stub.phi()<<endl;
	} else {
	  //cout << "Found DTC named "<<it3->second<<endl;
	  string dtc=it3->second;
	  //cout << "layer ladder module dtc :"<<layer<<" "<<ladder<<" "
	  //   <<module<<" "<<dtc<<endl;
	  std::pair<FPGAStub*,L1TStub*> stubpair(0,&stub);
	  //cout << "In dtcs look for:'"<<dtc<<"'"<<endl; 
	  assert(dtcs.find(dtc)!=dtcs.end());
	  int added=dtcs[dtc].addStub(stubpair);
	  if (overlapregion&&overlaplayer) {
	    if (added!=2) {
	      cout << "Warning: In overlap region add stub "<<layer<<" "
		   <<ladder<<" "
		   <<module<<" "<<stub.phi()<<"  to "<<added<<" links for dtc = "<<dtc<<endl;
	    }
	  } else {
	    if (added!=1) {
	      cout << "Warning: In non-overlap region add stub "<<layer<<" "
		   <<ladder<<" "
		   <<module<<" "<<stub.phi()<<"  to "<<added<<" links for dtc = "<<dtc<<endl;
	    }
	  }
	}
	//cout << "Done add stub"<<endl;	
      }
      */      

    }

/*
if (writeDTCLinks) {
  //cout << "Will write DTC links"<<endl;
  static ofstream out("dtclinks.txt");
  for (std::map<string,FPGADTC>::iterator iter=dtcs.begin();iter!=dtcs.end();iter++) {
    for (unsigned int j=0;j<iter->second.nLinks();j++) {
      out << iter->first << " " << j << " " << iter->second.link(j).nStubs() << endl;    
    }	 
  }
  //cout << "Done write DTC links"<<endl;
 }
*/

if (writestubs || writestubs_in2) {
  for (unsigned int k=0;k<NSector;k++) {
    if(k==writememsect)
      sectors[k]->writeInputStubs(first);
  }
 }

if (writeHitEff) {
        static ofstream outhit("hiteff.txt");
    	outhit << simtrk.eta()<<" "<<hitlayer[0] << " " << hitlayer[1] << " "
                  << hitlayer[2] << " " << hitlayer[3] << " "	  
		  << hitlayer[4] << " " << hitlayer[5] << endl;
    }

    if (writeStubsLayer) {
      static ofstream out("stubslayer.txt");
      out <<stublayer[0]<<" "<<stublayer[1]<<" "<<stublayer[2]<<" "
          <<stublayer[3]<<" "<<stublayer[4]<<" "<<stublayer[5]<<endl;
    }     


    if (writeStubsLayerperSector) {
      static ofstream out("stubslayerpersector.txt");
      for(unsigned int jj=0;jj<NSector;jj++){
        out <<stublayer1[0][jj]<<" "<<stublayer1[1][jj]<<" "
	    <<stublayer1[2][jj]<<" "
            <<stublayer1[3][jj]<<" "<<stublayer1[4][jj]<<" "
            <<stublayer1[5][jj]<<endl; 
      }
    }     


    
    if (0) {
      static ofstream out("newvmoccupancy.txt");
      for (unsigned int ll=0;ll<24*NSector;ll++){
        out<<1<<" "<<stubcount[0][ll]<<endl;
        out<<2<<" "<<stubcount[1][ll]<<endl;
        out<<3<<" "<<stubcount[2][ll]<<endl;
        out<<4<<" "<<stubcount[3][ll]<<endl;
        out<<5<<" "<<stubcount[4][ll]<<endl;
        out<<6<<" "<<stubcount[5][ll]<<endl;
      }
    } 



    addStubTimer.stop();


    //Now start processing


    layerdiskRouterTimer.start();
    for (unsigned int k=0;k<NSector;k++) {
      sectors[k]->executeLR();	 
      sectors[k]->executeDR();	
      if(writemem&&k==writememsect) {
        sectors[k]->writeSL(first);	 
        sectors[k]->writeSD(first);	 
      }      
    }
    layerdiskRouterTimer.stop();


    VMRouterTimer.start();
    for (unsigned int k=0;k<NSector;k++) {
      sectors[k]->executeVMR();	 
      if(writemem&&k==writememsect) {
        sectors[k]->writeVMSTE(first);	 
        sectors[k]->writeVMSME(first);	 
        sectors[k]->writeAS(first);	 
      }      
    }
    VMRouterTimer.stop();

    bool ptflag = true; // set false for pt cut in emulation

    if (ev.simtrack(0).pt() > 3 or fabs(ev.simtrack(0).eta()) > 1.0 or fabs(ev.simtrack(0).eta()) < 0.5) {
      ptflag = true;
    }

    TETimer.start();
    for (unsigned int k=0;k<NSector;k++) {
      sectors[k]->executeTE(ptflag);	
      if(writemem&&k==writememsect){
        sectors[k]->writeSP(first);
      } 
    }
    TETimer.stop();


    TCTimer.start();
    for (unsigned int k=0;k<NSector;k++) {
      sectors[k]->executeTC();	 
      if(writemem&&k==writememsect){
        sectors[k]->writeTPAR(first);
        sectors[k]->writeTPROJ(first);
      } 
    }
    TCTimer.stop();




    PTTimer.start();
    //Here we do the projections to the nearest neigbors  
    for (unsigned int k=0;k<NSector;k++) {
      unsigned int  plus=k+1;
      if (plus>=NSector) plus=0;
      int minus=k-1;
      if (minus<0) minus=NSector-1;
      sectors[k]->executePT(sectors[plus],sectors[minus]);	 
    }
    PTTimer.stop();



    PRTimer.start();
    for (unsigned int k=0;k<NSector;k++) {
      sectors[k]->executePR();	
      if(writemem&&k==writememsect){
        sectors[k]->writeVMPROJ(first);
        sectors[k]->writeAP(first);
      }
    }
    PRTimer.stop();

    
    METimer.start();
    for (unsigned int k=0;k<NSector;k++) {
      sectors[k]->executeME();	
      if(writemem&&k==writememsect){
        sectors[k]->writeCM(first);
      } 
    }
    METimer.stop();


    MCTimer.start();
    for (unsigned int k=0;k<NSector;k++) {
      sectors[k]->executeMC();
      if(writemem&&k==writememsect){
        sectors[k]->writeMC(first);
      }
    }
    MCTimer.stop();



    MTTimer.start();
    //Here we return the matches
    for (unsigned int k=0;k<NSector;k++) {
      unsigned int  plus=k+1;
      if (plus>=NSector) plus=0;
      int minus=k-1;
      if (minus<0) minus=NSector-1;
      sectors[k]->executeMT(sectors[plus],sectors[minus]);	 
    }
    MTTimer.stop();


    FTTimer.start();
    for (unsigned int k=0;k<NSector;k++) {
      sectors[k]->executeFT();	 
      if((writemem||writeifit)&&k==writememsect){
         sectors[k]->writeTF(first);
      }
    }
    FTTimer.stop();


    PDTimer.start();
    for (unsigned int k=0;k<NSector;k++) {
      sectors[k]->executePD(tracks);	  
      if(writeifit&&(k==1||k==2||k==3||k==4||k==5)){
         sectors[k]->writeCT(first);
      }
    }
    PDTimer.stop();

    bool match=false;
    for (unsigned int k=0;k<NSector;k++) {
      //cout << "FPGA.icc " << k << " " << tracks.size() << endl;
      //sectors[k]->findduplicates(tracks);
      if (selectmu==1) {
	if (ev.nsimtracks()>0) {
	  match=match||sectors[k]->foundTrack(outres,simtrk);
	}
      }
    }
    


    //Tag adjacent sector duplicates
    if(AdjacentRemoval) {
        for (int itrk=0; itrk<(int)tracks.size(); itrk++) {
            //if primary track is a duplicate, it cannot veto any...move on
            if(!tracks[itrk]->duplicate()) {          
        
                for(int jtrk=itrk+1; jtrk<(int)tracks.size(); jtrk++){
                //if secondary track is a duplicate or not in an adjacent sector, it cannot veto any...move on
                    if(!tracks[jtrk]->duplicate() && ( abs(tracks[itrk]->sector()-tracks[jtrk]->sector())==1 || abs(tracks[itrk]->sector()-tracks[jtrk]->sector())==27)) {

                        //get stub information
                        int nShare=0;
                        std::map<int, int> stubsTrk1 = tracks[itrk]->stubID();
                        std::map<int, int> stubsTrk2 = tracks[jtrk]->stubID();

                        //count shared stubs
                        for(std::map<int, int>::iterator  st=stubsTrk1.begin(); st!=stubsTrk1.end(); st++) {
                            if( stubsTrk2.find(st->first) != stubsTrk2.end() ) {
                                if(st->second == stubsTrk2[st->first] && st->second != 63) { nShare++; }
                            }             
                        } //loop over stubs

                        //Decide if we should flag either of the tracks as a duplicate
                        if(stubsTrk1.size()>=stubsTrk2.size()) {
                            if( (((int)stubsTrk2.size()-nShare)<minIndStubs) && !tracks[itrk]->duplicate() ) tracks[jtrk]->setDuplicate(true);
                        } else {
                            if( (((int)stubsTrk1.size()-nShare)<minIndStubs) && !tracks[jtrk]->duplicate() ) tracks[itrk]->setDuplicate(true);
                        }
                    } //if second track not a duplicate already
                } //loop over second track
            } //if first track not a duplicate already
        } //loop over first track
    } // Adjacent Removal

    if (writeResEff) {
       outeff << simtrk.pt()*simtrk.id()/fabs(simtrk.id())<<" "<<simtrk.eta()
       	      <<" "<<simtrk.phi();
       if (match) outeff << " 1"<<endl;
       else outeff << " 0"<<endl;
    }


